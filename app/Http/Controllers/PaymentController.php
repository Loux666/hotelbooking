<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use App\Models\Booking;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Mail;
use App\Mail\BookingSuccessMail;
use App\Mail\BookingCartSuccessMail;
use App\Models\RoomAvailability;
use App\Services\VNPayPayment;
use App\Models\Payment;
use App\Models\BookingDetail;
use App\Models\CouponUsage;
use App\Models\Coupon;
use App\Models\Cart;
use Illuminate\Support\Facades\Http;

class PaymentController extends Controller
{

    public function showPaymentOptions($bookingId)
    {
        $booking = Booking::where('id', $bookingId)
            ->where('status', 'pending')
            ->where('payment_status', 'unpaid')
            ->where(function ($q) {
                $q->whereNull('expired_at')->orWhere('expired_at', '>', now());
            })
            ->firstOrFail();

        return view('home.payment_method', compact('booking'));
    }
    public function initPayment(Request $request)
    {
        $request->validate([
            'booking_id' => 'required|exists:bookings,id',
            'method' => 'required|in:vnpay,momo,offline',
        ]);

        $booking = Booking::findOrFail($request->booking_id);

        if ($booking->status !== 'pending' || $booking->payment_status !== 'unpaid') {
            return redirect()->back()->with('error', 'ƒê∆°n h√†ng kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ thanh to√°n.');
            Log::error('ƒê∆°n h√†ng kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ thanh to√°n', [
                'booking_id' => $booking->id,
                'status' => $booking->status,
                'payment_status' => $booking->payment_status,
            ]);
        }

        switch ($request->method) {
            case 'vnpay':
                return $this->payWithVNPAY($request);
            case 'offline':
                return $this->payLater($request);
        }
    }


    public function payWithVnpay(Request $request)
    {
        Log::info('‚úÖ ƒê√É V√ÄO VNPAY [DIRECT BOOKING]');

        $bookingId = $request->input('booking_id');
        $booking = Booking::findOrFail($request->input('booking_id'));

        if (!$booking || $booking->status !== 'pending' || $booking->payment_status !== 'unpaid') {
            return redirect()->back()->with('error', 'ƒê∆°n h√†ng kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω.');
        }

        $orderId = $bookingId;
        $amount = $booking->total_price;

        $vnp_TmnCode = config('services.vnpay.tmn_code');
        $vnp_HashSecret = config('services.vnpay.hash_secret');
        $vnp_Url = config('services.vnpay.url');
        $vnp_Returnurl = config('services.vnpay.return_url');
        $vnp_IpAddr = $request->ip();

        $inputData = [
            "vnp_Version" => "2.1.0",
            "vnp_TmnCode" => $vnp_TmnCode,
            "vnp_Amount" => $amount * 100,
            "vnp_Command" => "pay",
            "vnp_CreateDate" => now()->format('YmdHis'),
            "vnp_CurrCode" => "VND",
            "vnp_IpAddr" => $vnp_IpAddr,
            "vnp_Locale" => "vn",
            "vnp_OrderInfo" => "Thanh toan GD: " . $orderId,
            "vnp_OrderType" => "billpayment",
            "vnp_ReturnUrl" => $vnp_Returnurl,
            "vnp_TxnRef" => $orderId,
        ];

        ksort($inputData);
        $hashdata = '';
        $query = '';
        foreach ($inputData as $key => $value) {
            $hashdata .= ($hashdata ? '&' : '') . urlencode($key) . '=' . urlencode($value);
            $query .= urlencode($key) . '=' . urlencode($value) . '&';
        }

        $vnpSecureHash = hash_hmac('sha512', $hashdata, $vnp_HashSecret);
        $finalUrl = $vnp_Url . '?' . $query . 'vnp_SecureHash=' . $vnpSecureHash;

        Log::info('‚úÖ FINAL VNPAY URL:', ['url' => $finalUrl]);

        return redirect($finalUrl);
    }

    public function vnpayCallback(Request $request)
    {
        Log::info('üî• [REAL CALLBACK] ƒê√£ v√†o vnpayCallback', $request->all());

        $inputData = $request->query();
        $vnp_HashSecret = config('services.vnpay.hash_secret');
        $vnp_SecureHash = $inputData['vnp_SecureHash'] ?? '';

        if (!isset($inputData['vnp_TxnRef'], $inputData['vnp_ResponseCode'])) {
            Log::error('‚ùå Thi·∫øu d·ªØ li·ªáu b·∫Øt bu·ªôc t·ª´ VNPAY');
            return view('home.payment_failed', ['message' => 'Thi·∫øu d·ªØ li·ªáu c·∫ßn thi·∫øt t·ª´ VNPAY.']);
        }

        $bookingId = $inputData['vnp_TxnRef'];
        $booking = Booking::with('booking_details')->find($bookingId);
        $tmp = Cache::get('booking_tmp_' . $bookingId);

        if (!$tmp || !$booking || $booking->status !== 'pending') {
            Log::error('‚ùå Kh√¥ng t√¨m th·∫•y booking ho·∫∑c cache kh√¥ng t·ªìn t·∫°i', [
                'booking_id' => $bookingId,
                'booking' => $booking,
                'tmp' => $tmp,
            ]);
            return view('home.payment_failed', ['message' => 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ho·∫∑c ƒë√£ x·ª≠ l√Ω.']);
        }

        // X√°c minh ch·ªØ k√Ω
        $tempData = $inputData;
        unset($tempData['vnp_SecureHash'], $tempData['vnp_SecureHashType']);
        ksort($tempData);
        $hashdata = http_build_query($tempData);
        $secureHash = hash_hmac('sha512', $hashdata, $vnp_HashSecret);

        if ($secureHash !== $vnp_SecureHash) {
            Log::error('‚ùå Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá');
            return view('home.payment_failed', ['message' => 'Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá']);
        }

        if ($inputData['vnp_ResponseCode'] !== '00') {
            Log::error('‚ùå Giao d·ªãch th·∫•t b·∫°i v·ªõi m√£: ' . $inputData['vnp_ResponseCode']);
            return view('home.payment_failed', ['message' => 'Giao d·ªãch kh√¥ng th√†nh c√¥ng']);
        }

        if (Payment::where('txn_ref', $bookingId)->exists()) {
            Log::warning('‚ö†Ô∏è ƒê∆°n ƒë√£ ƒë∆∞·ª£c thanh to√°n t·ª´ tr∆∞·ªõc');
            return redirect()->route('payment.success.existing', ['booking_id' => $bookingId]);
        }

        // B·∫Øt ƒë·∫ßu ghi DB
        try {
            DB::beginTransaction();
            Log::info('üìù B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t c√°c b·∫£ng booking, booking_detail, payments...');

            $booking->update([
                'status' => 'confirmed',
                'expired_at' => null,
                'payment_status' => 'paid'
            ]);

            // T·∫°o booking_detail
            $discount = $tmp['discount'] ?? 0;
            $subtotal = $tmp['room_price'] * $tmp['nights'] + ($tmp['room_price'] * $tmp['nights']) * 0.10 + 100000;

            BookingDetail::create([
                'booking_id' => $booking->id,
                'room_id' => $tmp['room_id'],
                'hotel_id' => $tmp['hotel_id'],
                'room_name' => $tmp['room_name'],
                'price_per_night' => $tmp['room_price'],
                'nights' => $tmp['nights'],
                'quantity' => 1,
                'subtotal' => $subtotal,
                'payment_status' => 'paid',
                'discount' => $discount,
                'checkin' => $tmp['checkin_date'],
                'checkout' => $tmp['checkout_date'],
            ]);

            // C·∫≠p nh·∫≠t RoomAvailability
            $start = \Carbon\Carbon::parse($tmp['checkin_date']);
            $end = \Carbon\Carbon::parse($tmp['checkout_date']);
            for ($date = $start->copy(); $date->lt($end); $date->addDay()) {
                RoomAvailability::where('room_id', $tmp['room_id'])
                    ->where('date', $date->toDateString())
                    ->decrement('available_rooms', 1);
            }

            // T·∫°o b·∫£n ghi thanh to√°n
            $paidAt = now();
            if (isset($inputData['vnp_PayDate'])) {
                try {
                    $paidAt = \Carbon\Carbon::createFromFormat('YmdHis', $inputData['vnp_PayDate']);
                } catch (\Exception $e) {
                    Log::warning('‚ö†Ô∏è L·ªói parse th·ªùi gian thanh to√°n: ' . $e->getMessage());
                }
            }

            Payment::create([
                'booking_id' => $booking->id,
                'txn_ref' => $inputData['vnp_TxnRef'] ?? '',
                'transaction_no' => $inputData['vnp_TransactionNo'] ?? '',
                'bank_code' => $inputData['vnp_BankCode'] ?? '',
                'card_type' => $inputData['vnp_CardType'] ?? '',
                'amount' => ($inputData['vnp_Amount'] ?? 0) / 100,
                'payment_gateway' => 'vnpay',
                'status' => 'success',
                'paid_at' => $paidAt,
            ]);

            //  N·∫øu c√≥ coupon ƒë√£ l∆∞u trong cache th√¨ c·∫≠p nh·∫≠t l∆∞·ª£t s·ª≠ d·ª•ng
            if (isset($tmp['coupon_id'], $tmp['discount']) && Auth::check()) {
                Log::info('üéüÔ∏è C√≥ m√£ gi·∫£m gi√°, ti·∫øn h√†nh c·∫≠p nh·∫≠t l∆∞·ª£t d√πng');

                CouponUsage::updateOrCreate(
                    ['coupon_id' => $tmp['coupon_id'], 'user_id' => Auth::id()],
                    ['used_count' => DB::raw('used_count + 1')]
                );

                Coupon::where('id', $tmp['coupon_id'])->increment('used_count');
            }

            DB::commit();
            Cache::forget('booking_tmp_' . $bookingId);

            // G·ª≠i mail
            try {
                $booking->load('booking_details.hotel');
                Mail::to($booking->guest_email)->send(new BookingSuccessMail($booking));
                Log::info('üìß G·ª≠i mail x√°c nh·∫≠n th√†nh c√¥ng');
            } catch (\Exception $e) {
                Log::warning('‚ö†Ô∏è G·ª≠i mail th·∫•t b·∫°i: ' . $e->getMessage());
            }

            return redirect()->route('payment.success.existing', ['booking_id' => $booking->id]);
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('‚ùå L·ªói khi x·ª≠ l√Ω callback', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            return view('home.payment_failed', ['message' => 'C√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω giao d·ªãch.']);
        }
    }
    public function payLater(Request $request)
    {
        Log::info('‚úÖ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω thanh to√°n tr·∫£ sau (offline)');
        $bookingId = $request->input('booking_id');

        DB::beginTransaction();

        try {
            $booking = Booking::findOrFail($bookingId);
            $tmp = Cache::get('booking_tmp_' . $bookingId);

            // Ki·ªÉm tra cache c√≤n t·ªìn t·∫°i kh√¥ng
            if (!$tmp) {
                return redirect()->back()->with('error', 'Th√¥ng tin ƒë·∫∑t ph√≤ng ƒë√£ h·∫øt h·∫°n. Vui l√≤ng th·ª≠ l·∫°i.');
            }

            // Ki·ªÉm tra tr·∫°ng th√°i h·ª£p l·ªá
            if ($booking->status !== 'pending' || $booking->payment_status !== 'unpaid') {
                return redirect()->back()->with('error', 'ƒê∆°n h√†ng kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω.');
            }

            // C·∫≠p nh·∫≠t tr·∫°ng th√°i booking
            $booking->update([
                'status' => 'confirmed',
                'payment_status' => 'unpaid',
                'expired_at' => null,
            ]);
            Log::info('üìù C·∫≠p nh·∫≠t tr·∫°ng th√°i booking th√†nh c√¥ng', ['booking_id' => $booking->id]);

            // T·∫°o booking detail

            $discount = $tmp['discount'] ?? 0;
            $subtotal = $tmp['room_price'] * $tmp['nights'] + ($tmp['room_price'] * $tmp['nights']) * 0.10 + 100000;

            BookingDetail::create([
                'booking_id' => $booking->id,
                'room_id' => $tmp['room_id'],
                'hotel_id' => $tmp['hotel_id'],
                'room_name' => $tmp['room_name'],
                'price_per_night' => $tmp['room_price'],
                'nights' => $tmp['nights'],
                'quantity' => 1,
                'subtotal' => $subtotal,
                'payment_status' => 'unpaid',
                'discount' => $discount,
                'checkin' => $tmp['checkin_date'],
                'checkout' => $tmp['checkout_date'],
            ]);
            Log::info('üìù T·∫°o booking detail th√†nh c√¥ng', ['booking_id' => $booking->id]);

            // T·∫°o payment offline
            Payment::create([
                'booking_id' => $booking->id,
                'txn_ref' => 'OFFLINE_' . strtoupper(Str::random(10)),
                'transaction_no' => null,
                'bank_code' => null,
                'card_type' => null,
                'amount' => $booking->total_price,
                'payment_gateway' => 'offline',
                'status' => 'pending',
                'paid_at' => now(),
            ]);
            Log::info('üìù T·∫°o b·∫£n ghi thanh to√°n th√†nh c√¥ng', ['booking_id' => $booking->id]);

            // C·∫≠p nh·∫≠t RoomAvailability
            $start = \Carbon\Carbon::parse($tmp['checkin_date']);
            $end = \Carbon\Carbon::parse($tmp['checkout_date']);

            for ($date = $start->copy(); $date->lt($end); $date->addDay()) {
                RoomAvailability::where('room_id', $tmp['room_id'])
                    ->where('date', $date->toDateString())
                    ->decrement('available_rooms', 1);
            }

            Log::info('üìù C·∫≠p nh·∫≠t RoomAvailability th√†nh c√¥ng', [
                'room_id' => $tmp['room_id'],
                'booking_id' => $bookingId,
                'range' => [$start->toDateString(), $end->toDateString()]
            ]);

            // N·∫øu c√≥ coupon ‚Üí c·∫≠p nh·∫≠t l∆∞·ª£t d√πng
            if (isset($tmp['coupon_id'], $tmp['discount']) && Auth::check()) {
                Log::info('üéüÔ∏è C√≥ m√£ gi·∫£m gi√°, ti·∫øn h√†nh c·∫≠p nh·∫≠t l∆∞·ª£t d√πng');

                CouponUsage::updateOrCreate(
                    ['coupon_id' => $tmp['coupon_id'], 'user_id' => Auth::id()],
                    ['used_count' => DB::raw('used_count + 1')]
                );

                Coupon::where('id', $tmp['coupon_id'])->increment('used_count');

                Log::info('üìù C·∫≠p nh·∫≠t l∆∞·ª£t d√πng coupon th√†nh c√¥ng', ['coupon_id' => $tmp['coupon_id']]);
            }

            // X√≥a cache t·∫°m
            Cache::forget('booking_tmp_' . $bookingId);

            // G·ª≠i mail x√°c nh·∫≠n
            try {
                $booking->load('booking_details.hotel');
                Mail::to($booking->guest_email)->send(new BookingSuccessMail($booking));
                Log::info('üìß G·ª≠i mail x√°c nh·∫≠n th√†nh c√¥ng', ['booking_id' => $booking->id]);
            } catch (\Exception $e) {
                Log::warning('‚ö†Ô∏è G·ª≠i mail th·∫•t b·∫°i', ['error' => $e->getMessage()]);
            }

            DB::commit();

            return redirect()->route('payment.success.existing', ['booking_id' => $booking->id]);
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('‚ùå L·ªói khi x·ª≠ l√Ω thanh to√°n offline', ['error' => $e->getMessage()]);
            return redirect()->back()->with('error', 'ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i.');
        }
    }









    //Cart payment
    public function showPaymentOptionsCart($bookingId)
    {
        $booking = Booking::where('id', $bookingId)
            ->where('status', 'pending')
            ->where('payment_status', 'unpaid')
            ->where(function ($q) {
                $q->whereNull('expired_at')->orWhere('expired_at', '>', now());
            })
            ->firstOrFail();

        // L·∫•y discount t·ª´ cache
        $cacheData = Cache::get("cart-booking-{$bookingId}");
        $discount = $cacheData['discount'] ?? 0;
        Log::info('[CART SHOW PAYMENT] Booking loaded:', [
            'id' => $booking->id,
            'total_price' => $booking->total_price,
            'coupon_id' => $booking->coupon_id,
        ]);

        return view('home.payment_method_cart', compact('booking', 'discount'));
    }

    public function initPaymentCart(Request $request)
    {

        $request->validate([
            'booking_id' => 'required|exists:bookings,id',
            'method' => 'required|in:vnpay,momo,offline',
        ]);

        $booking = Booking::findOrFail($request->booking_id);

        if ($booking->status !== 'pending' || $booking->payment_status !== 'unpaid') {
            return redirect()->back()->with('error', 'ƒê∆°n h√†ng kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ thanh to√°n.');
        }

        switch ($request->method) {
            case 'vnpay':
                return $this->payWithVnpayFromCart($request);
            case 'offline':
                return $this->payLaterCart($request);
        }
    }
    public function payWithVnpayFromCart(Request $request)
    {
        Log::info(' Nh·∫≠n request thanh to√°n:', $request->all());

        $cacheKey = $request->input('cache_key');
        Log::info('Nh·∫≠n cache key:', ['cache_key' => $cacheKey]);

        $booking = Cache::get($cacheKey);

        if (!$booking) {
            Log::warning('Booking not found in cache', [
                'user_id' => Auth::id(),
                'cache_key' => $cacheKey,
            ]);

            return redirect()->back()->with('error', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin booking.');
        }

        Log::info('Booking found in cache:', ['booking' => $booking]);

        $vnp_TmnCode = config('services.vnpay.tmn_code');
        $vnp_HashSecret = config('services.vnpay.hash_secret');
        $vnp_Url = config('services.vnpay.url');
        $vnp_Returnurl = route('payment.vnpay.callback.cart');

        Log::debug(' VNPAY Config:', [
            'tmn_code' => $vnp_TmnCode,
            'hash_secret_exists' => $vnp_HashSecret ? true : false,
            'url' => $vnp_Url,
            'return_url' => $vnp_Returnurl,
        ]);

        if (!$vnp_TmnCode || !$vnp_HashSecret || !$vnp_Url) {
            Log::error(' VNPAY config missing', [
                'user_id' => Auth::id(),
            ]);

            return redirect()->back()->with('error', 'C·∫•u h√¨nh c·ªïng thanh to√°n ch∆∞a ƒë·∫ßy ƒë·ªß.');
        }

        $orderId = $cacheKey; // üëà ƒë·∫£m b·∫£o ƒë√∫ng format "cart-booking-xx"
        $amount = (int) $booking['final_total'];

        Log::info(' Th√¥ng tin thanh to√°n:', [
            'order_id' => $orderId,
            'amount' => $amount,
        ]);

        $inputData = [
            "vnp_Version" => "2.1.0",
            "vnp_TmnCode" => $vnp_TmnCode,
            "vnp_Amount" => $amount * 100,
            "vnp_Command" => "pay",
            "vnp_CreateDate" => now()->format('YmdHis'),
            "vnp_CurrCode" => "VND",
            "vnp_IpAddr" => $request->ip(),
            "vnp_Locale" => "vn",
            "vnp_OrderInfo" => "Thanh to√°n gi·ªè h√†ng",
            "vnp_OrderType" => "billpayment",
            "vnp_ReturnUrl" => $vnp_Returnurl,
            "vnp_TxnRef" => $orderId,
        ];

        Log::debug(' D·ªØ li·ªáu g·ª≠i sang VNPAY (ch∆∞a k√Ω):', $inputData);

        ksort($inputData);
        $hashdata = '';
        foreach ($inputData as $key => $value) {
            $hashdata .= ($hashdata ? '&' : '') . urlencode($key) . '=' . urlencode($value);
        }

        $vnpSecureHash = hash_hmac('sha512', $hashdata, $vnp_HashSecret);
        $vnp_Url .= '?' . http_build_query($inputData) . '&vnp_SecureHash=' . $vnpSecureHash;

        Log::info(' Redirecting to VNPAY...', [
            'user_id' => Auth::id(),
            'cache_key' => $cacheKey,
            'amount' => $amount,
            'redirect_url' => $vnp_Url,
        ]);

        return redirect($vnp_Url);
    }


    public function vnpayCallbackCart(Request $request)
    {
        Log::info('=== [VNPAY CALLBACK START] ===');
        $inputData = $request->all();
        Log::info('[VNPAY] D·ªØ li·ªáu callback:', $inputData);

        $vnp_HashSecret = config('services.vnpay.hash_secret');
        $vnp_SecureHash = $inputData['vnp_SecureHash'] ?? '';
        $cacheKey = $inputData['vnp_TxnRef'] ?? '';

        Log::debug('[VNPAY] TxnRef:', ['cache_key' => $cacheKey]);

        if (!isset($inputData['vnp_TxnRef'], $inputData['vnp_ResponseCode'])) {
            Log::warning('[VNPAY] Thi·∫øu d·ªØ li·ªáu b·∫Øt bu·ªôc t·ª´ callback.');
            return view('home.payment_failed', ['message' => 'Thi·∫øu d·ªØ li·ªáu t·ª´ VNPAY.']);
        }

        $cacheData = Cache::get($cacheKey);
        if (!$cacheData || !is_array($cacheData)) {
            Log::warning('[VNPAY] Kh√¥ng t√¨m th·∫•y booking trong cache ho·∫∑c sai ƒë·ªãnh d·∫°ng', ['cache_key' => $cacheKey]);
            return view('home.payment_failed', ['message' => 'Th√¥ng tin booking ƒë√£ h·∫øt h·∫°n.']);
        }

        Log::debug('[VNPAY] D·ªØ li·ªáu cache:', $cacheData);

        // ‚úÖ X√°c minh ch·ªØ k√Ω
        $tempData = $inputData;
        unset($tempData['vnp_SecureHash'], $tempData['vnp_SecureHashType']);
        ksort($tempData);
        $hashData = http_build_query($tempData, '', '&');
        $secureHash = hash_hmac('sha512', $hashData, $vnp_HashSecret);

        if ($secureHash !== $vnp_SecureHash) {
            Log::error('[VNPAY] Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá.');
            return view('home.payment_failed', ['message' => 'Ch·ªØ k√Ω kh√¥ng h·ª£p l·ªá.']);
        }

        if ($inputData['vnp_ResponseCode'] !== '00') {
            Log::info('[VNPAY] Giao d·ªãch kh√¥ng th√†nh c√¥ng.', ['code' => $inputData['vnp_ResponseCode']]);
            return view('home.payment_failed', ['message' => 'Giao d·ªãch kh√¥ng th√†nh c√¥ng.']);
        }

        if (Payment::where('txn_ref', $cacheKey)->exists()) {
            Log::info('[VNPAY] Giao d·ªãch ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω tr∆∞·ªõc ƒë√≥.');
            return redirect()->route('payment.success.existing', ['txn_ref' => $cacheKey]);
        }

        DB::beginTransaction();
        try {
            Log::info('[VNPAY] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω giao d·ªãch...');

            $bookingModel = Booking::findOrFail($cacheData['booking_id']);

            $bookingModel->update([
                'status' => 'confirmed',
                'payment_status' => 'paid',
                'expired_at' => null,
            ]);
            Log::info('[VNPAY] C·∫≠p nh·∫≠t tr·∫°ng th√°i booking th√†nh c√¥ng', ['booking_id' => $bookingModel->id]);

            $rooms = $cacheData['rooms'];
            $totalBeforeDiscount = collect($rooms)->sum('total_price');
            $totalDiscount = $cacheData['discount'] ?? 0;

            foreach ($rooms as $room) {
                $roomDiscount = $totalBeforeDiscount > 0
                    ? round(($room['total_price'] / $totalBeforeDiscount) * $totalDiscount)
                    : 0;

                BookingDetail::create([
                    'booking_id' => $bookingModel->id,
                    'room_id' => $room['room_id'],
                    'checkin' => $room['checkin'],
                    'checkout' => $room['checkout'],
                    'price_per_night' => $room['price_per_night'],
                    'nights' => $room['nights'],
                    'subtotal' => $room['total_price'],
                    'discount' => $roomDiscount,
                    'room_name' => $room['room_name'],
                    'hotel_id' => $room['hotel_id'],
                    'quantity' => 1,
                    'payment_status' => 'paid',
                ]);

                // Gi·∫£m room_availabilities
                $start = \Carbon\Carbon::parse($room['checkin']);
                $end = \Carbon\Carbon::parse($room['checkout']);
                for ($date = $start->copy(); $date->lt($end); $date->addDay()) {
                    RoomAvailability::where('room_id', $room['room_id'])
                        ->where('date', $date->toDateString())
                        ->decrement('available_rooms', 1);
                }
            }

            $paidAt = now();
            if (isset($inputData['vnp_PayDate'])) {
                try {
                    $paidAt = \Carbon\Carbon::createFromFormat('YmdHis', $inputData['vnp_PayDate']);
                } catch (\Exception $e) {
                    Log::warning('[VNPAY] L·ªói parse ng√†y thanh to√°n: ' . $e->getMessage());
                }
            }

            Payment::create([
                'booking_id' => $bookingModel->id,
                'txn_ref' => $inputData['vnp_TxnRef'],
                'transaction_no' => $inputData['vnp_TransactionNo'] ?? '',
                'bank_code' => $inputData['vnp_BankCode'] ?? '',
                'card_type' => $inputData['vnp_CardType'] ?? '',
                'amount' => ($inputData['vnp_Amount'] ?? 0) / 100,
                'payment_gateway' => 'vnpay',
                'status' => 'success',
                'paid_at' => $paidAt,
            ]);

            if (isset($cacheData['coupon_id'], $cacheData['discount']) && Auth::check()) {
                Log::info('[VNPAY] √Åp d·ª•ng coupon:', [
                    'coupon_id' => $cacheData['coupon_id'],
                    'user_id' => Auth::id(),
                ]);

                CouponUsage::updateOrCreate(
                    ['coupon_id' => $cacheData['coupon_id'], 'user_id' => Auth::id()],
                    ['used_count' => DB::raw('used_count + 1')]
                );

                Coupon::where('id', $cacheData['coupon_id'])->increment('used_count');
            }

            Cart::whereIn('id', $cacheData['cart_ids'])->delete();
            Log::info('[VNPAY] ƒê√£ xo√° gi·ªè h√†ng c·ªßa user', ['user_id' => $cacheData['user_id']]);

            Cache::forget($cacheKey);
            Log::info('[VNPAY] ƒê√£ xo√° cache:', ['cache_key' => $cacheKey]);

            DB::commit();

            try {
                $bookingWithDetails = $bookingModel->load('booking_details.room.hotel');
                Mail::to($bookingModel->guest_email)->send(new \App\Mail\BookingCartSuccessMail($bookingWithDetails));
                Log::info('[VNPAY] G·ª≠i mail th√†nh c√¥ng t·ªõi:', ['email' => $bookingModel->guest_email]);
            } catch (\Exception $e) {
                Log::warning('[VNPAY] G·ª≠i mail th·∫•t b·∫°i: ' . $e->getMessage());
            }

            return redirect()->route('payment.success.existing', ['booking_id' => $bookingModel->id]);
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('[VNPAY] L·ªói x·ª≠ l√Ω callback: ' . $e->getMessage());
            return view('home.payment_failed', ['message' => 'L·ªói x·ª≠ l√Ω giao d·ªãch: ' . $e->getMessage()]);
        }
    }

    public function payLaterCart(Request $request)
    {
        Log::info(' B·∫Øt ƒë·∫ßu x·ª≠ l√Ω thanh to√°n tr·∫£ sau (offline)');

        $bookingId = $request->input('booking_id');
        $cacheKey = $request->input('cache_key');
        $cacheData = Cache::get($cacheKey);

        if (!$cacheData) {
            return redirect()->back()->with('error', 'Th√¥ng tin gi·ªè h√†ng ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒë·∫∑t l·∫°i.');
        }

        DB::beginTransaction();

        try {
            $booking = Booking::findOrFail($bookingId);

            // Ki·ªÉm tra tr·∫°ng th√°i
            if ($booking->status !== 'pending' || $booking->payment_status !== 'unpaid') {
                return redirect()->back()->with('error', 'ƒê∆°n h√†ng kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω.');
            }

            // C·∫≠p nh·∫≠t tr·∫°ng th√°i booking
            $booking->update([
                'status' => 'confirmed',
                'expired_at' => null,
            ]);
            Log::info('üìù  C·∫≠p nh·∫≠t tr·∫°ng th√°i booking th√†nh c√¥ng', ['booking_id' => $booking->id]);

            $rooms = $cacheData['rooms'];
            $totalBeforeDiscount = collect($rooms)->sum('total_price');
            $totalDiscount = $cacheData['discount'] ?? 0;

            // T·∫°o booking_details cho t·ª´ng ph√≤ng
            foreach ($rooms as $room) {
                // Chia discount theo t·ª∑ l·ªá
                $roomDiscount = $totalBeforeDiscount > 0
                    ? round(($room['total_price'] / $totalBeforeDiscount) * $totalDiscount)
                    : 0;

                BookingDetail::create([
                    'booking_id' => $booking->id,
                    'room_id' => $room['room_id'],
                    'checkin' => $room['checkin'],
                    'checkout' => $room['checkout'],
                    'price_per_night' => $room['price_per_night'],
                    'nights' => $room['nights'],
                    'subtotal' => $room['total_price'],
                    'discount' => $roomDiscount,
                    'room_name' => $room['room_name'],
                    'hotel_id' => $room['hotel_id'],
                    'quantity' => 1,
                    'payment_status' => 'unpaid',

                ]);

                // C·∫≠p nh·∫≠t RoomAvailability t·ª´ng ng√†y
                $start = \Carbon\Carbon::parse($room['checkin']);
                $end = \Carbon\Carbon::parse($room['checkout']);
                for ($date = $start->copy(); $date->lt($end); $date->addDay()) {
                    RoomAvailability::where('room_id', $room['room_id'])
                        ->where('date', $date->toDateString())
                        ->decrement('available_rooms', 1);
                }
            }

            Log::info('üìù  T·∫°o booking_details v√† c·∫≠p nh·∫≠t RoomAvailability xong');

            // Ghi log payment offline (status success v√¨ ƒë√£ x√°c nh·∫≠n, ch∆∞a tr·∫£ ti·ªÅn)
            Payment::create([
                'booking_id' => $booking->id,
                'txn_ref' => 'OFFLINE_' . strtoupper(Str::random(10)),
                'transaction_no' => null,
                'bank_code' => null,
                'card_type' => null,
                'amount' => $cacheData['final_total'],
                'payment_gateway' => 'offline',
                'status' => 'pending',
                'paid_at' => now(),
            ]);
            Log::info('üìù  Ghi nh·∫≠n thanh to√°n offline th√†nh c√¥ng');

            // N·∫øu c√≥ coupon
            if (isset($cacheData['coupon_id'], $cacheData['discount']) && Auth::check()) {
                CouponUsage::updateOrCreate(
                    ['coupon_id' => $cacheData['coupon_id'], 'user_id' => Auth::id()],
                    ['used_count' => DB::raw('used_count + 1')]
                );

                Coupon::where('id', $cacheData['coupon_id'])->increment('used_count');

                Log::info('üéüÔ∏è C·∫≠p nh·∫≠t l∆∞·ª£t d√πng coupon th√†nh c√¥ng', ['coupon_id' => $cacheData['coupon_id']]);
            }

            // Xo√° c√°c cart items ƒë√£ ƒë·∫∑t
            Cart::whereIn('id', $cacheData['cart_ids'])->delete();

            // Xo√° cache t·∫°m
            Cache::forget($cacheKey);

            // G·ª≠i mail
            try {
                $booking->load(['booking_details.room', 'booking_details.room.hotel']);
                Mail::to($booking->guest_email)->send(new BookingSuccessMail($booking));
                Log::info('üìß  G·ª≠i mail x√°c nh·∫≠n th√†nh c√¥ng', ['booking_id' => $booking->id]);
            } catch (\Exception $e) {
                Log::warning('‚ö†Ô∏è G·ª≠i mail th·∫•t b·∫°i', ['error' => $e->getMessage()]);
            }

            DB::commit();

            return redirect()->route('payment.success.existing', ['booking_id' => $booking->id])
                ->with('success', 'ƒê·∫∑t ph√≤ng th√†nh c√¥ng. Thanh to√°n khi nh·∫≠n ph√≤ng.');
        } catch (\Exception $e) {
            DB::rollBack();
            Log::error('‚ùå L·ªói khi x·ª≠ l√Ω thanh to√°n offline', ['error' => $e->getMessage()]);
            return redirect()->back()->with('error', 'ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω ƒë∆°n h√†ng. Vui l√≤ng th·ª≠ l·∫°i.');
        }
    }









    // private function getAccessToken()
    // {
    //     $response = Http::asForm()->withBasicAuth(
    //         env('PAYPAL_CLIENT_ID'),
    //         env('PAYPAL_SECRET')
    //     )->post(env('PAYPAL_BASE_URL') . '/v1/oauth2/token', [
    //         'grant_type' => 'client_credentials',
    //     ]);

    //     return $response->json()['access_token'];
    // }

    // public function createOrder()
    // {
    //     $accessToken = $this->getAccessToken();

    //     $response = Http::withToken($accessToken)->post(env('PAYPAL_BASE_URL') . '/v2/checkout/orders', [
    //         'intent' => 'CAPTURE',
    //         'purchase_units' => [[
    //             'amount' => [
    //                 'currency_code' => 'USD',
    //                 'value' => '10.00'
    //             ]
    //         ]],
    //         'application_context' => [
    //             'return_url' => route('paypal.success'),
    //             'cancel_url' => route('paypal.cancel')
    //         ]
    //     ]);

    //     $order = $response->json();

    //     if (isset($order['links'])) {
    //         foreach ($order['links'] as $link) {
    //             if ($link['rel'] === 'approve') {
    //                 return redirect()->away($link['href']);
    //             }
    //         }
    //     }

    //     return redirect()->back()->with('error', 'L·ªói khi t·∫°o ƒë∆°n h√†ng PayPal.');
    // }

    // public function capture(Request $request)
    // {
    //     $accessToken = $this->getAccessToken();

    //     $response = Http::withToken($accessToken)->post(env('PAYPAL_BASE_URL') . '/v2/checkout/orders/' . $request->query('token') . '/capture');

    //     $data = $response->json();

    //     if (isset($data['status']) && $data['status'] === 'COMPLETED') {
    //         // X·ª≠ l√Ω booking, l∆∞u DB, x√≥a cart v.v...
    //         return redirect()->route('your.success.page')->with('success', 'Thanh to√°n th√†nh c√¥ng!');
    //     }

    //     return redirect()->route('your.cancel.page')->with('error', 'Thanh to√°n th·∫•t b·∫°i!');
    // }

    // public function cancel()
    // {
    //     return redirect()->route('your.cancel.page')->with('error', 'B·∫°n ƒë√£ hu·ª∑ thanh to√°n.');
    // }




















    public function showExisting(Request $request)
    {
        // $txnRef = $request->txn_ref;


        // $payment = \App\Models\Payment::where('txn_ref', $txnRef)->with('booking')->first();

        // if (!$payment || !$payment->booking) {
        //     return view('home.payment_failed', ['message' => 'Kh√¥ng t√¨m th·∫•y th√¥ng tin giao d·ªãch.']);
        // }

        return view('home.payment_success', [
            // 'booking' => $payment->booking,
            // 'payment' => $payment,
        ]);
    }
}
